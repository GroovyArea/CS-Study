# 심화 문제

## 1. 프로세스 간 통신을 통신 방향에 따라 분류하여 설명
- 단방향 통신
  - 한 방향으로만 데이터 전송 가능.
  - 전역 변수와 파이프
- 반양방향 통신
  - 양방향으로 전송 가능
  - 동시 전송 불가
  - 무전기
- 양방향 통신
  - 데이터를 동시에 양방향으로 전송 가능
  - 일반적인 통신 구조

## 2. 대기가 있는 통신과 대기가 없는 통신의 의미를 설명하고 적절한 예를 제시하시오.
- 바쁜 대기 (busy waiting)
  - 상태 변화를 살펴보기 위해 반복문을 통해 무한 실행하며 기다리는 것. 
  - 데이터가 도착함을 알려주는 동기화를 통해 해결
  - 사용할 경우 운영 체제가 알아서 알려준다.

1. 대기 O 
  - 동기화 통신
  - 동기화를 지원하는 통신 방식
  - 데이터 도착까지 대기 상태
  - 파이프, 소켓
2. 대기 X
  - 비동기화 통신
  - 데이터 수신쪽은 바쁜 대기 사용
  - 전역 변수, 파일

## 3. 실생활의 예를 들어 임계구역 문제를 설명
- 영화관 동일 좌석 동시 예매 상황

## 4. 다음 코드의 문제점을 설명
![심화문제 4번](./img/5%EC%9E%A5%204%EB%B2%88%EB%AC%B8%EC%A0%9C.png)
- 상호 배제 문제가 발생하는 전형적 예시
- 두 개의 프로세스가 각각  while문을 실행하여 임계 구역에 진입하는 상황이다.

## 5. 다음 코드의 문제점을 설명
![심화문제 5번](./img/5%EC%9E%A5%205%EB%B2%88%EB%AC%B8%EC%A0%9C.png)
- 진행의 융통성 문제가 발생하는 전형적 예시
- 하나의 프로세스가 임계구역에 두번 진입하고 싶어도 그러지 못한다.
- 우선순위의 의미가 없다.

## 6. 파일을 이용해 Test라는 문자를 주고 받는 코드 작성
```C
#include<stdio.h>
#include<unistd.h>
#include<fcntl.h>

void main() {
  int pid, fd;
    char buf[5];

    fd = open("test.txt", O_RDWR);
    pid = fork();

    if (pid < 0 || fd < 0)
        exit(-1);
    else if (pid == 0)
    {
        write(fd, "Test", 5);
        close(fd);
        exit(0);
    }
    else
    {
        wait(0);
        lseek(fd, 0, SEEK_SET);
        read(fd, buf, 5);
        printf("%s", buf);
        close(fd);
        exit(0);
    }
}
```